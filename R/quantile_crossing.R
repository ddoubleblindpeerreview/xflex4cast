#' @importFrom data.table data.table :=
#' @importFrom stats predict quantile sigma
#' @importFrom utils data flush.console
NULL

#' Quantile crossing correction
#'
#' Correct the quantile estimations in a long-format `data.table` generated by a
#' `p4r_model` object  by reordering the quantiles values in a increasing order
#' with respect to each level.
#'
#'
#' @param predictions probabilistic fault forecasts a long-format `data.table`
#' containing the indexes, quantiles and respective value columns.
#' @param indexes List specifying column names with required element:
#' \itemize{
#'   \item `valid_time` Column containing target time or NWP valid time.
#'   Default \code{"dtm"}.
#'   }
#'
#' @return A long-format `data.table` containing correctly reordered quantile
#' predictions.
#' @keywords internal
#' @noRd
quantile_crossing_correction <- function(predictions,
                                         indexes){

  # Checking if the indexes is null, otherwise will incorrectly sort the quantiles
  if(is.null(indexes)){
    stop('Insert valid indexes for quantile crossing correction.')
  }

  # Verifying if all indexes, quantiles and values are within the prediction
  #data.table.

  if(!(all(indexes %in% colnames(predictions)))){
    stop('There is an invalid index for the prediction data.table.')
  }

  if(!all(c('quantile','value') %in% colnames(predictions))){
    stop('No quantile and value column found in the prediction data.table.')
  }



  # Reordering the quantiles values to avoid unsroted quantiles in the long-table
  predictions[!all(cummax(quantile)==quantile),quantile := sort(quantile), by = indexes]

  # Re-ordering the quantiles estimations in case of quantile-crossing
  predictions[!all(cummax(value)==value),value := sort(value), by = indexes]

  return(predictions)
}
